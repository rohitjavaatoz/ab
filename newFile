import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.mongodb.core.MongoTemplate;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
public class TabService {

    @Autowired
    private MongoTemplate mongoTemplate; // Autowire your MongoDB template or repository

    public TabsResponseDTO getFilteredTabs() {
        // Assuming you have a method to fetch data from MongoDB
        List<Tab> tabs = mongoTemplate.findAll(Tab.class); // Replace Tab with your actual MongoDB entity class

        // Map and filter the data to DTO
        List<TabDTO> tabDTOs = tabs.stream()
                .map(this::mapTabToDTO)
                .collect(Collectors.toList());

        TabsResponseDTO responseDTO = new TabsResponseDTO();
        responseDTO.setTabs(tabDTOs);

        return responseDTO;
    }

    private TabDTO mapTabToDTO(Tab tab) {
        TabDTO tabDTO = new TabDTO();
        tabDTO.setName(tab.getName());

        List<AttributeDTO> attributeDTOs = tab.getAttributes().stream()
                .map(this::mapAttributeToDTO)
                .collect(Collectors.toList());

        tabDTO.setAttributes(attributeDTOs);

        return tabDTO;
    }

    private AttributeDTO mapAttributeToDTO(Attribute attribute) {
        AttributeDTO attributeDTO = new AttributeDTO();
        attributeDTO.setName(attribute.getName());
        attributeDTO.setMaintenanceType(attribute.getMaintenanceType());
        attributeDTO.setCicImpacted(attribute.getCicImpacted()); // Assuming getCicImpacted returns Boolean

        return attributeDTO;
    }
}
-------
import com.albertsons.meitem.constants.GlobalConstants;
import com.albertsons.meitem.model.mongo.maintenance.Attribute;
import com.albertsons.meitem.model.mongo.maintenance.Tab;
import com.albertsons.meitem.model.mongo.maintenance.TabsCollection;
import com.albertsons.meitem.repository.mongo.MaintainMetadataRepository;
import com.albertsons.meitem.response.maintenace.AttributeDTO;
import com.albertsons.meitem.response.maintenace.ResponsePayloadDTO;
import com.albertsons.meitem.response.maintenace.TabDTO;
import com.albertsons.meitem.utils.RequestContextManager;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

public class MaintenanceMetaServiceImplTest {

    @Mock
    private MaintainMetadataRepository maintainMetadataRepository;

    @Mock
    private RequestContextManager requestContextManager;

    @InjectMocks
    private MaintenanceMetaServiceImpl maintenanceMetaService;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testGetMaintenanceMeta_Success() {
        when(requestContextManager.getValue(GlobalConstants.AUTHROLE)).thenReturn("VENDOR");

        TabsCollection tabsCollection = new TabsCollection();
        tabsCollection.setTabs(createTabsList());
        when(maintainMetadataRepository.findByTabsAttributesIsEditableBy("VENDOR")).thenReturn(Collections.singletonList(tabsCollection));

        ResponsePayloadDTO response = maintenanceMetaService.getMaintenanceMeta();

        verify(maintainMetadataRepository, times(1)).findByTabsAttributesIsEditableBy("VENDOR");

        assertEquals(2, response.getTabs().size());

        TabDTO overviewTabDTO = response.getTabs().get(0);
        assertEquals("overview", overviewTabDTO.getName());
        assertEquals(3, overviewTabDTO.getAttributes().size());

        assertAttributeEquals("itemDescription", "WATCHFUL", false, overviewTabDTO.getAttributes().get(0));
        assertAttributeEquals("itemSize", "WATCHFUL", true, overviewTabDTO.getAttributes().get(1));
        assertAttributeEquals("digitalProductTitle", "NON-WATCHFUL", false, overviewTabDTO.getAttributes().get(2));
    }

    @Test
    public void testGetMaintenanceMeta_EmptyResponse() {
        when(requestContextManager.getValue(GlobalConstants.AUTHROLE)).thenReturn("MDS");

        when(maintainMetadataRepository.findByTabsAttributesIsEditableBy("MDS")).thenReturn(Collections.emptyList());

        ResponsePayloadDTO response = maintenanceMetaService.getMaintenanceMeta();

        verify(maintainMetadataRepository, times(1)).findByTabsAttributesIsEditableBy("MDS");

        assertNotNull(response);
        assertTrue(response.getTabs().isEmpty());
    }

    @Test
    public void testGetMaintenanceMeta_ExceptionInRepositoryCall() {
        when(requestContextManager.getValue(GlobalConstants.AUTHROLE)).thenReturn("ADMIN");

        when(maintainMetadataRepository.findByTabsAttributesIsEditableBy("ADMIN")).thenThrow(RuntimeException.class);

        assertThrows(RuntimeException.class, () -> maintenanceMetaService.getMaintenanceMeta());

        verify(maintainMetadataRepository, times(1)).findByTabsAttributesIsEditableBy("ADMIN");
    }

    @Test
    public void testFilterAttributesByEditableBy_Success() {
        TabsCollection tabsCollection = createTabsCollection();

        TabsCollection filteredTabsCollection = maintenanceMetaService.filterAttributesByEditableBy(tabsCollection, "MDS");

        assertEquals(2, filteredTabsCollection.getTabs().size());

        Tab overviewTab = filteredTabsCollection.getTabs().get(0);
        assertEquals("overview", overviewTab.getName());
        assertEquals(1, overviewTab.getAttributes().size());
        assertAttributeEquals("itemDescription", "WATCHFUL", false, overviewTab.getAttributes().get(0));
    }

    @Test
    public void testFilterAttributesByEditableBy_EmptyAttributes() {
        TabsCollection tabsCollection = new TabsCollection();
        tabsCollection.setTabs(createTabsList(Collections.emptyList()));

        TabsCollection filteredTabsCollection = maintenanceMetaService.filterAttributesByEditableBy(tabsCollection, "VENDOR");

        assertTrue(filteredTabsCollection.getTabs().isEmpty());
    }

    @Test
    public void testFilterAttributesByEditableBy_ExceptionInFiltering() {
        TabsCollection tabsCollection = createTabsCollection();
        tabsCollection.getTabs().get(0).getAttributes().get(0).setIsEditableBy(null);

        assertThrows(RuntimeException.class, () -> maintenanceMetaService.filterAttributesByEditableBy(tabsCollection, "VENDOR"));
    }

    private TabsCollection createTabsCollection() {
        TabsCollection tabsCollection = new TabsCollection();
        tabsCollection.setTabs(createTabsList());
        return tabsCollection;
    }

    private List<Tab> createTabsList() {
        List<Tab> tabs = new ArrayList<>();
        tabs.add(createTab("overview", createAttributesOverview()));
        tabs.add(createTab("hierarchy", createAttributesHierarchy()));
        return tabs;
    }

    private Tab createTab(String name, List<Attribute> attributes) {
        Tab tab = new Tab();
        tab.setName(name);
        tab.setAttributes(attributes);
        return tab;
    }

    private List<Attribute> createAttributesOverview() {
        List<Attribute> attributes = new ArrayList<>();
        attributes.add(createAttribute("itemDescription", "WATCHFUL", Arrays.asList("VENDOR", "MDS"), false));
        attributes.add(createAttribute("itemSize", "WATCHFUL", Collections.singletonList("MDS"), true));
        attributes.add(createAttribute("digitalProductTitle", "NON-WATCHFUL", Collections.singletonList("VENDOR"), false));
        return attributes;
    }

    private List<Attribute> createAttributesHierarchy() {
        List<Attribute> attributes = new ArrayList<>();
        attributes.add(createAttribute("description", "NON-WATCHFUL", Collections.singletonList("MDS"), false));
        attributes.add(createAttribute("size", "WATCHFUL", Arrays.asList("VENDOR", "MDS"), true));
        return attributes;
    }

    private Attribute createAttribute(String name, String maintenanceType, List<String> editableBy, boolean cicImpacted) {
        Attribute attribute = new Attribute();
        attribute.setName(name);
        attribute.setMaintenanceType(maintenanceType);
        attribute.setIsEditableBy(editableBy);
        attribute.setCicImpacted(cicImpacted);
        return attribute;
    }

    private void assertAttributeEquals(String expectedName, String expectedMaintenanceType, boolean expectedCicImpacted, AttributeDTO actual) {
        assertEquals(expectedName, actual.getName());
        assertEquals(expectedMaintenanceType, actual.getMaintenanceType());
        assertEquals(expectedCicImpacted, actual.isCicImpacted());
    }
}
