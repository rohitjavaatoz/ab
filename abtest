package com.albertsons.meitem.service.itemv2;

import com.albertsons.meitem.constants.GlobalConstants;
import com.albertsons.meitem.model.mongo.maintenance.Attribute;
import com.albertsons.meitem.model.mongo.maintenance.Tab;
import com.albertsons.meitem.model.mongo.maintenance.TabsCollection;
import com.albertsons.meitem.repository.mongo.MaintainMetadataRepository;
import com.albertsons.meitem.response.maintenace.AttributeDTO;
import com.albertsons.meitem.response.maintenace.ResponsePayloadDTO;
import com.albertsons.meitem.response.maintenace.TabDTO;
import com.albertsons.meitem.utils.RequestContextManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
public class MaintenanceMetaServiceImpl implements MaintenanceMetaService {

    @Autowired
    MaintainMetadataRepository maintainMetadataRepository;

    @Override
    public ResponsePayloadDTO getMaintenanceMeta() {
        try {
            String authRole = String.valueOf(RequestContextManager.getValue(GlobalConstants.AUTHROLE)).toUpperCase();
            List<TabsCollection> allMetadata = maintainMetadataRepository.findByTabsAttributesIsEditableBy(authRole);

            List<TabDTO> tabDTOs = allMetadata.stream()
                    .flatMap(employee -> employee.getTabs().stream()
                            .map(tab -> mapTabDTO(tab, authRole)))
                    .collect(Collectors.toList());

            ResponsePayloadDTO responsePayloadDTO = new ResponsePayloadDTO();
            responsePayloadDTO.setTabs(tabDTOs);

            return responsePayloadDTO;
        } catch (Exception e) {
            throw new RuntimeException("Exception while fetching the data", e);
        }
    }

    private TabDTO mapTabDTO(Tab tab, String authRole) {
        TabDTO tabDTO = new TabDTO();
        tabDTO.setName(tab.getName());

        List<AttributeDTO> attributeDTOs = tab.getAttributes().stream()
                .filter(attribute -> attribute.getIsEditableBy().contains(authRole))
                .map(this::mapAttributeDTO)
                .collect(Collectors.toList());

        tabDTO.setAttributes(attributeDTOs);
        return tabDTO;
    }

    private AttributeDTO mapAttributeDTO(Attribute attribute) {
        AttributeDTO attributeDTO = new AttributeDTO();
        attributeDTO.setName(attribute.getName());
        attributeDTO.setMaintenanceType(attribute.getMaintenanceType());
        attributeDTO.setCicImpacted(attribute.getCicImpacted() != null ? attribute.getCicImpacted() : false);
        return attributeDTO;
    }
}
---------------------------
package com.albertsons.meitem.service.itemv2;

import com.albertsons.meitem.constants.GlobalConstants;
import com.albertsons.meitem.model.mongo.maintenance.Attribute;
import com.albertsons.meitem.model.mongo.maintenance.Tab;
import com.albertsons.meitem.model.mongo.maintenance.TabsCollection;
import com.albertsons.meitem.repository.mongo.MaintainMetadataRepository;
import com.albertsons.meitem.response.maintenace.AttributeDTO;
import com.albertsons.meitem.response.maintenace.ResponsePayloadDTO;
import com.albertsons.meitem.response.maintenace.TabDTO;
import com.albertsons.meitem.utils.RequestContextManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

@Service
@Slf4j
public class MaintenanceMetaServiceImpl implements MaintenanceMetaService {

    @Autowired
    MaintainMetadataRepository maintainMetadataRepository;

    @Override
    public ResponsePayloadDTO getMaintenanceMeta() {
        try {
            String authRole = String.valueOf(RequestContextManager.getValue(GlobalConstants.AUTHROLE)).toUpperCase();
            List<TabsCollection> allMetadata = maintainMetadataRepository.findByTabsAttributesIsEditableBy(authRole);

            List<TabDTO> tabDTOs = allMetadata.stream()
                    .flatMap(employee -> employee.getTabs().stream()
                            .map(tab -> mapTabDTO(tab, authRole)))
                    .collect(Collectors.toList());

            ResponsePayloadDTO responsePayloadDTO = new ResponsePayloadDTO();
            responsePayloadDTO.setTabs(tabDTOs);

            return responsePayloadDTO;
        } catch (Exception e) {
            log.error("Exception while fetching metadata: {}", e.getMessage());
            throw new RuntimeException("Exception while fetching the data", e);
        }
    }

    private TabDTO mapTabDTO(Tab tab, String authRole) {
        Objects.requireNonNull(tab, "Tab must not be null");

        TabDTO tabDTO = new TabDTO();
        tabDTO.setName(tab.getName());

        List<AttributeDTO> attributeDTOs = tab.getAttributes().stream()
                .filter(attribute -> attribute.getIsEditableBy() != null && attribute.getIsEditableBy().contains(authRole))
                .map(this::mapAttributeDTO)
                .collect(Collectors.toList());

        tabDTO.setAttributes(attributeDTOs);
        return tabDTO;
    }

    private AttributeDTO mapAttributeDTO(Attribute attribute) {
        Objects.requireNonNull(attribute, "Attribute must not be null");

        AttributeDTO attributeDTO = new AttributeDTO();
        attributeDTO.setName(attribute.getName());
        attributeDTO.setMaintenanceType(attribute.getMaintenanceType());
        attributeDTO.setCicImpacted(attribute.getCicImpacted() != null ? attribute.getCicImpacted() : false);
        return attributeDTO;
    }
}
--------------------
package com.albertsons.meitem.service.itemv2;

import com.albertsons.meitem.constants.GlobalConstants;
import com.albertsons.meitem.model.mongo.maintenance.Attribute;
import com.albertsons.meitem.model.mongo.maintenance.Tab;
import com.albertsons.meitem.model.mongo.maintenance.TabsCollection;
import com.albertsons.meitem.repository.mongo.MaintainMetadataRepository;
import com.albertsons.meitem.response.maintenace.AttributeDTO;
import com.albertsons.meitem.response.maintenace.ResponsePayloadDTO;
import com.albertsons.meitem.response.maintenace.TabDTO;
import com.albertsons.meitem.utils.RequestContextManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@Slf4j
public class MaintenanceMetaServiceImpl implements MaintenanceMetaService {

    @Autowired
    MaintainMetadataRepository maintainMetadataRepository;

    @Override
    public ResponsePayloadDTO getMaintenanceMeta() {
        try {
            String authRole = String.valueOf(RequestContextManager.getValue(GlobalConstants.AUTHROLE)).toUpperCase();
            List<TabsCollection> allMetadata = maintainMetadataRepository.findByTabsAttributesIsEditableBy(authRole);

            List<TabDTO> tabDTOs = allMetadata.stream()
                    .flatMap(employee -> employee.getTabs().stream()
                            .map(tab -> mapTabDTO(tab, authRole)))
                    .collect(Collectors.toList());

            ResponsePayloadDTO responsePayloadDTO = new ResponsePayloadDTO();
            responsePayloadDTO.setTabs(tabDTOs);

            return responsePayloadDTO;
        } catch (Exception e) {
            log.error("Exception while fetching metadata: {}", e.getMessage());
            throw new RuntimeException("Exception while fetching the data", e);
        }
    }

    private TabDTO mapTabDTO(Tab tab, String authRole) {
        TabDTO tabDTO = new TabDTO();
        tabDTO.setName(tab.getName());

        List<AttributeDTO> attributeDTOs = tab.getAttributes().stream()
                .filter(attribute -> isAttributeValid(attribute, authRole))
                .map(this::mapAttributeDTO)
                .collect(Collectors.toList());

        tabDTO.setAttributes(attributeDTOs);
        return tabDTO;
    }

    private boolean isAttributeValid(Attribute attribute, String authRole) {
        return Optional.ofNullable(attribute)
                .map(Attribute::getIsEditableBy)
                .map(editables -> editables.contains(authRole))
                .orElse(false);
    }

    private AttributeDTO mapAttributeDTO(Attribute attribute) {
        AttributeDTO attributeDTO = new AttributeDTO();
        attributeDTO.setName(attribute.getName());
        attributeDTO.setMaintenanceType(attribute.getMaintenanceType());
        attributeDTO.setCicImpacted(attribute.getCicImpacted() != null ? attribute.getCicImpacted() : false);
        return attributeDTO;
    }
}
-------------------------------
package com.albertsons.meitem.service.itemv2;

import com.albertsons.meitem.constants.GlobalConstants;
import com.albertsons.meitem.model.mongo.maintenance.Attribute;
import com.albertsons.meitem.model.mongo.maintenance.Tab;
import com.albertsons.meitem.model.mongo.maintenance.TabsCollection;
import com.albertsons.meitem.repository.mongo.MaintainMetadataRepository;
import com.albertsons.meitem.response.maintenace.AttributeDTO;
import com.albertsons.meitem.response.maintenace.MaintenanceMetaDataDTO;
import com.albertsons.meitem.response.maintenace.TabDTO;
import com.albertsons.meitem.utils.RequestContextManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
public class MaintenanceMetaDataServiceImpl implements MaintenanceMetaDataService {

    @Autowired
    MaintainMetadataRepository maintainMetadataRepository;


    @Override
    public MaintenanceMetaDataDTO getMaintenanceMeta() {
        try {
            String authRole = String.valueOf(RequestContextManager.getValue(GlobalConstants.AUTHROLE)).toUpperCase();
            List<TabsCollection> MentenanceMetaData = maintainMetadataRepository.findByTabsAttributesIsEditableByContaining(authRole);
            MentenanceMetaData.stream().map(document -> filterAttributesByEditableBy(document, authRole)).collect(Collectors.toList());
            List<TabDTO> tabDTOs = MentenanceMetaData.stream()
                    .flatMap(employee -> employee.getTabs().stream()
                            .map(tab -> mapTabDTO(tab, authRole)))
                    .collect(Collectors.toList());
            MaintenanceMetaDataDTO responsePayloadDTO = new MaintenanceMetaDataDTO();
            responsePayloadDTO.setTabs(tabDTOs);
            return responsePayloadDTO;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }

    private TabDTO mapTabDTO(Tab tab, String authRole) {
        TabDTO tabDTO = new TabDTO();
        tabDTO.setName(tab.getName());
        List<AttributeDTO> attributeDTOs = tab.getAttributes().stream()
                .filter(attribute -> attribute.getIsEditableBy().contains(authRole))
                .map(this::mapAttributeDTO)
                .collect(Collectors.toList());
        tabDTO.setAttributes(attributeDTOs);
        return tabDTO;
    }

    private AttributeDTO mapAttributeDTO(Attribute attribute) {
        AttributeDTO attributeDTO = new AttributeDTO();
        attributeDTO.setName(attribute.getName());
        attributeDTO.setMaintenanceType(attribute.getMaintenanceType());
        attributeDTO.setCicImpacted(attribute.getCicImpacted() != null ? attribute.getCicImpacted() : false);
        return attributeDTO;
    }

    TabsCollection filterAttributesByEditableBy(TabsCollection document, String editableBy) {
        try {
            List<Tab> filteredTabs = document.getTabs().stream().map(tab -> {
                List<Attribute> filteredAttributes = tab.getAttributes().stream().filter(attr -> attr.getIsEditableBy().contains(editableBy)).collect(Collectors.toList());
                tab.setAttributes(filteredAttributes);
                return tab;
            }).filter(tab -> !tab.getAttributes().isEmpty()).collect(Collectors.toList());
            document.setTabs(filteredTabs);
            List<AttributeDTO> attributes = new ArrayList<>();
            return document;
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
    }
}
