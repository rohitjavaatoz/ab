package com.albertsons.meitem.controller.item.maintenance;

import com.albertsons.meitem.configuration.ResponseHandler;
import com.albertsons.meitem.document.item.maintenance.MaintenanceMetaDataApiDocument;
import com.albertsons.meitem.response.maintenace.ResponsePayloadDTO;
import com.albertsons.meitem.service.itemv2.MaintenanceMetaServiceImpl;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
@Slf4j
@Tag(name = "metadata APIs", description = "Endpoints for metadata")

public class MaintenanceMetaDataController implements MaintenanceMetaDataApiDocument {

    @Autowired
    MaintenanceMetaServiceImpl maintenanceMetaServiceImpl;

    @Override
    public ResponseEntity<Object> getMaintenanceMetadata() {

        return ResponseHandler.generateResponse(HttpStatus.OK, maintenanceMetaServiceImpl.getMaintenanceMeta());

    }
}
----------------------------------
package com.albertsons.meitem.controller.item.maintenance;

import com.albertsons.meitem.configuration.ResponseHandler;
import com.albertsons.meitem.response.maintenace.ResponsePayloadDTO;
import com.albertsons.meitem.service.itemv2.MaintenanceMetaServiceImpl;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

public class MaintenanceMetaDataControllerTest {

    @Mock
    private MaintenanceMetaServiceImpl maintenanceMetaService;

    @InjectMocks
    private MaintenanceMetaDataController maintenanceMetaDataController;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testGetMaintenanceMetadata_Success() {
        // Mock service response
        ResponsePayloadDTO mockPayload = new ResponsePayloadDTO();
        when(maintenanceMetaService.getMaintenanceMeta()).thenReturn(mockPayload);

        // Call controller method
        ResponseEntity<Object> responseEntity = maintenanceMetaDataController.getMaintenanceMetadata();

        // Verify service method was called once
        verify(maintenanceMetaService, times(1)).getMaintenanceMeta();

        // Assert response status and body
        assertEquals(HttpStatus.OK, responseEntity.getStatusCode());
        assertEquals(mockPayload, responseEntity.getBody());
    }

    // Add more test cases as needed to cover different scenarios
}

-------------------
package com.albertsons.meitem.service.itemv2;

import com.albertsons.meitem.constants.GlobalConstants;
import com.albertsons.meitem.model.mongo.maintenance.Attribute;
import com.albertsons.meitem.model.mongo.maintenance.Tab;
import com.albertsons.meitem.model.mongo.maintenance.TabsCollection;
import com.albertsons.meitem.repository.mongo.MaintainMetadataRepository;
import com.albertsons.meitem.response.maintenace.AttributeDTO;
import com.albertsons.meitem.response.maintenace.ResponsePayloadDTO;
import com.albertsons.meitem.response.maintenace.TabDTO;
import com.albertsons.meitem.utils.RequestContextManager;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
public class MaintenanceMetaServiceImpl implements MaintenanceMetaService {

    @Autowired
    MaintainMetadataRepository maintainMetadataRepository;


    @Override
    public ResponsePayloadDTO getMaintenanceMeta() {
        try {
            String authRole = String.valueOf(RequestContextManager.getValue(GlobalConstants.AUTHROLE)).toUpperCase();
            List<TabsCollection> allMetadata = maintainMetadataRepository.findByTabsAttributesIsEditableBy(authRole);
            allMetadata.stream().map(document -> filterAttributesByEditableBy(document, authRole)).collect(Collectors.toList());
            ResponsePayloadDTO responsePayloadDTO = new ResponsePayloadDTO();
            List<TabDTO> tabDTOs = new ArrayList<>();
            List<AttributeDTO> attributeDTOs = new ArrayList<>();
            for (TabsCollection employee : allMetadata) {
                for (Tab tab : employee.getTabs()) {
                    for (Attribute attribute : tab.getAttributes()) {
                        AttributeDTO attributeDTO = new AttributeDTO();
                        attributeDTO.setName(attribute.getName());
                        attributeDTO.setMaintenanceType(attribute.getMaintenanceType());
                        if (attribute.getCicImpacted() != null) {
                            attributeDTO.setCicImpacted(attribute.getCicImpacted());
                        }
                        attributeDTOs.add(attributeDTO);
                    }
                    TabDTO tabDTO = new TabDTO();
                    tabDTO.setName(tab.getName());
                    tabDTO.setAttributes(attributeDTOs);
                    tabDTOs.add(tabDTO);
                }
                responsePayloadDTO.setTabs(tabDTOs);
            }
            return responsePayloadDTO;
        }catch (Exception e){
            throw new RuntimeException("Exception wile fetching the data"+e);
        }
    }

    private TabsCollection filterAttributesByEditableBy(TabsCollection document, String editableBy) {
      try {
          List<Tab> filteredTabs = document.getTabs().stream().map(tab -> {
              List<Attribute> filteredAttributes = tab.getAttributes().stream().filter(attr -> attr.getIsEditableBy().contains(editableBy)).collect(Collectors.toList());
              tab.setAttributes(filteredAttributes);
              return tab;
          }).filter(tab -> !tab.getAttributes().isEmpty()).collect(Collectors.toList());
          document.setTabs(filteredTabs);
          List<AttributeDTO> attributes = new ArrayList<>();
          return document;
      }catch (Exception e){
          throw new RuntimeException("exception wile filtering the data"+e);
      }
    }
}
-------
import com.albertsons.meitem.constants.GlobalConstants;
import com.albertsons.meitem.model.mongo.maintenance.Attribute;
import com.albertsons.meitem.model.mongo.maintenance.Tab;
import com.albertsons.meitem.model.mongo.maintenance.TabsCollection;
import com.albertsons.meitem.repository.mongo.MaintainMetadataRepository;
import com.albertsons.meitem.response.maintenace.AttributeDTO;
import com.albertsons.meitem.response.maintenace.ResponsePayloadDTO;
import com.albertsons.meitem.response.maintenace.TabDTO;
import com.albertsons.meitem.utils.RequestContextManager;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

public class MaintenanceMetaServiceImplTest {

    @Mock
    private MaintainMetadataRepository maintainMetadataRepository;

    @Mock
    private RequestContextManager requestContextManager;

    @InjectMocks
    private MaintenanceMetaServiceImpl maintenanceMetaService;

    @BeforeEach
    public void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    public void testGetMaintenanceMeta_Success() {
        // Mock RequestContextManager to return a dummy auth role
        String dummyAuthRole = "ADMIN";
        when(requestContextManager.getValue(GlobalConstants.AUTHROLE)).thenReturn(dummyAuthRole);

        // Mock repository response
        TabsCollection tabsCollection = new TabsCollection();
        tabsCollection.setTabs(Arrays.asList(
                new Tab("Tab1", Arrays.asList(new Attribute("Attr1", "Type1", Arrays.asList("ADMIN")))),
                new Tab("Tab2", Arrays.asList(new Attribute("Attr2", "Type2", Arrays.asList("ADMIN"))))
        ));
        when(maintainMetadataRepository.findByTabsAttributesIsEditableBy(dummyAuthRole)).thenReturn(Arrays.asList(tabsCollection));

        // Call service method
        ResponsePayloadDTO response = maintenanceMetaService.getMaintenanceMeta();

        // Verify repository method was called once
        verify(maintainMetadataRepository, times(1)).findByTabsAttributesIsEditableBy(dummyAuthRole);

        // Assert response content
        assertEquals(2, response.getTabs().size()); // Assuming two tabs were returned
        assertEquals("Tab1", response.getTabs().get(0).getName());
        assertEquals(1, response.getTabs().get(0).getAttributes().size()); // Assuming one attribute in Tab1
        assertEquals("Attr1", response.getTabs().get(0).getAttributes().get(0).getName());
    }

    @Test
    public void testFilterAttributesByEditableBy_Success() {
        // Create dummy TabsCollection with attributes
        TabsCollection tabsCollection = new TabsCollection();
        tabsCollection.setTabs(Arrays.asList(
                new Tab("Tab1", Arrays.asList(new Attribute("Attr1", "Type1", Arrays.asList("ADMIN", "MANAGER")))),
                new Tab("Tab2", Arrays.asList(new Attribute("Attr2", "Type2", Arrays.asList("ADMIN"))))
        ));

        // Call service method
        TabsCollection filteredTabsCollection = maintenanceMetaService.filterAttributesByEditableBy(tabsCollection, "ADMIN");

        // Assert filtering result
        assertEquals(2, filteredTabsCollection.getTabs().size()); // Both tabs should be retained for "ADMIN"
        assertEquals(1, filteredTabsCollection.getTabs().get(0).getAttributes().size()); // One attribute in Tab1 for "ADMIN"
    }
}
