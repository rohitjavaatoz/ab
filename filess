package com.albertsons.meitem.service.maintanance.impl;

import com.albertsons.meitem.constants.GlobalConstants;
import com.albertsons.meitem.features.ItemFeatures;
import com.albertsons.meitem.model.mongo.maintenance.Attribute;
import com.albertsons.meitem.model.mongo.maintenance.Tab;
import com.albertsons.meitem.model.mongo.maintenance.TabModel;
import com.albertsons.meitem.repository.mongo.MaintainMetadataRepository;
import com.albertsons.meitem.response.maintenace.AttributeResponse;
import com.albertsons.meitem.response.maintenace.MaintenanceMetaDataResponse;
import com.albertsons.meitem.response.maintenace.TabResponse;
import com.albertsons.meitem.service.maintanance.MaintenanceMetaDataService;
import com.albertsons.meitem.utils.RequestContextManager;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.togglz.core.manager.FeatureManager;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class MaintenanceMetaDataServiceImpl implements MaintenanceMetaDataService {

    private final MaintainMetadataRepository maintainMetadataRepository;
    private final FeatureManager featureManager;

    /**
     * Retrieves maintenance metadata based on the user's role.
     * This method fetches filter data from the maintain_metadata collection.
     * If the feature flag ITEM_MAINTENANCE is active, it returns the metadata.
     * Otherwise, an empty response is returned.
     *
     * @return A MaintenanceMetaDataResponse containing information about tabs and attributes.
     * @throws RuntimeException if there's an error fetching the maintenance info.
     */

    @Override
    public MaintenanceMetaDataResponse getMaintenanceMeta() {
        try {
            if (featureManager.isActive(ItemFeatures.ITEM_MAINTENANCE)) {
                String authRole = String.valueOf(RequestContextManager.getValue(GlobalConstants.AUTHROLE)).toUpperCase();
                List<TabModel> mentenanceMetaData = maintainMetadataRepository.findByTabsAttributesIsEditableByContaining(authRole);
                List<TabResponse> tabResponse = processTabs(mentenanceMetaData, authRole);
                return MaintenanceMetaDataResponse.builder()
                        .tabs(tabResponse)
                        .build();
            }
            return new MaintenanceMetaDataResponse();
        } catch (Exception exception) {
            log.error("Failed to fetch Maintenance Info: ", exception);
            throw new RuntimeException(exception);
        }
    }
    private List<TabResponse> processTabs(List<TabModel> mentenanceMetaData, String authRole) {
        List<TabResponse> tabResponse = mentenanceMetaData.stream()
                .flatMap(metaData -> metaData.getTabs().stream()
                        .map(tab -> getTabResponse(tab, authRole)))
                .collect(Collectors.toList());
        return tabResponse;
    }
    private TabResponse getTabResponse(Tab tab, String authRole) {
        return TabResponse.builder()
                .name(tab.getName())
                .attributes(tab.getAttributes().stream()
                        .filter(attribute -> attribute.getIsEditableBy().contains(authRole))
                        .map(attribute -> AttributeResponse.builder()
                                .name(attribute.getName())
                                .maintenanceType(attribute.getMaintenanceType())
                                .cicImpacted(attribute.getCicImpacted() != null && attribute.getCicImpacted())
                                .build())
                        .collect(Collectors.toList()))
                .build();
    }

    public TabModel filterAttributesByEditableBy(TabModel tabsCollection, String editableBy) {
            List<Tab> filteredTabs = tabsCollection.getTabs().stream().map(tab -> {
                List<Attribute> filteredAttributes = tab.getAttributes().stream().filter(attr -> attr.getIsEditableBy().contains(editableBy)).collect(Collectors.toList());
                tab.setAttributes(filteredAttributes);
                return tab;
            }).filter(tab -> !tab.getAttributes().isEmpty()).collect(Collectors.toList());
            tabsCollection.setTabs(filteredTabs);
            return tabsCollection;
        }
    }
}
