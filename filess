package com.albertsons.meitem.service.maintanance.impl;

import com.albertsons.meitem.constants.GlobalConstants;
import com.albertsons.meitem.features.ItemFeatures;
import com.albertsons.meitem.model.mongo.maintenance.Attribute;
import com.albertsons.meitem.model.mongo.maintenance.Tab;
import com.albertsons.meitem.model.mongo.maintenance.TabModel;
import com.albertsons.meitem.repository.mongo.MaintainMetadataRepository;
import com.albertsons.meitem.response.maintenace.AttributeResponse;
import com.albertsons.meitem.response.maintenace.MaintenanceMetaDataResponse;
import com.albertsons.meitem.response.maintenace.TabResponse;
import com.albertsons.meitem.service.maintanance.MaintenanceMetaDataService;
import com.albertsons.meitem.utils.RequestContextManager;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.togglz.core.manager.FeatureManager;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class MaintenanceMetaDataServiceImpl implements MaintenanceMetaDataService {

    private final MaintainMetadataRepository maintainMetadataRepository;
    private final FeatureManager featureManager;

    /**
     * Retrieves maintenance metadata based on the user's role.
     * This method fetches filter data from the maintain_metadata collection.
     * If the feature flag ITEM_MAINTENANCE is active, it returns the metadata.
     * Otherwise, an empty response is returned.
     *
     * @return A MaintenanceMetaDataResponse containing information about tabs and attributes.
     * @throws RuntimeException if there's an error fetching the maintenance info.
     */

    @Override
    public MaintenanceMetaDataResponse getMaintenanceMeta() {
        try {
            if (featureManager.isActive(ItemFeatures.ITEM_MAINTENANCE)) {
                String authRole = String.valueOf(RequestContextManager.getValue(GlobalConstants.AUTHROLE)).toUpperCase();
                List<TabModel> mentenanceMetaData = maintainMetadataRepository.findByTabsAttributesIsEditableByContaining(authRole);
                List<TabResponse> tabResponse = processTabs(mentenanceMetaData, authRole);
                return MaintenanceMetaDataResponse.builder()
                        .tabs(tabResponse)
                        .build();
            }
            return new MaintenanceMetaDataResponse();
        } catch (Exception exception) {
            log.error("Failed to fetch Maintenance Info: ", exception);
            throw new RuntimeException(exception);
        }
    }
    private List<TabResponse> processTabs(List<TabModel> mentenanceMetaData, String authRole) {
        List<TabResponse> tabResponse = mentenanceMetaData.stream()
                .flatMap(metaData -> metaData.getTabs().stream()
                        .map(tab -> getTabResponse(tab, authRole)))
                .collect(Collectors.toList());
        return tabResponse;
    }
    private TabResponse getTabResponse(Tab tab, String authRole) {
        return TabResponse.builder()
                .name(tab.getName())
                .attributes(tab.getAttributes().stream()
                        .filter(attribute -> attribute.getIsEditableBy().contains(authRole))
                        .map(attribute -> AttributeResponse.builder()
                                .name(attribute.getName())
                                .maintenanceType(attribute.getMaintenanceType())
                                .cicImpacted(attribute.getCicImpacted() != null && attribute.getCicImpacted())
                                .build())
                        .collect(Collectors.toList()))
                .build();
    }

    public TabModel filterAttributesByEditableBy(TabModel tabsCollection, String editableBy) {
            List<Tab> filteredTabs = tabsCollection.getTabs().stream().map(tab -> {
                List<Attribute> filteredAttributes = tab.getAttributes().stream().filter(attr -> attr.getIsEditableBy().contains(editableBy)).collect(Collectors.toList());
                tab.setAttributes(filteredAttributes);
                return tab;
            }).filter(tab -> !tab.getAttributes().isEmpty()).collect(Collectors.toList());
            tabsCollection.setTabs(filteredTabs);
            return tabsCollection;
        }
    }
}
----------------
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Override
public MaintenanceMetaDataResponse getMaintenanceMeta() {
    try {
        if (featureManager.isActive(ItemFeatures.ITEM_MAINTENANCE)) {
            Optional<String> authRoleOptional = Optional.ofNullable(RequestContextManager.getValue(GlobalConstants.AUTHROLE))
                    .filter(role -> role instanceof String)
                    .map(role -> ((String) role).trim().toUpperCase());

            if (authRoleOptional.isPresent() && !authRoleOptional.get().isEmpty()) {
                String authRole = authRoleOptional.get();
                
                List<TabModel> maintenanceMetaData = maintainMetadataRepository.findByTabsAttributesIsEditableByContaining(authRole);
                List<TabResponse> tabResponse = processTabs(maintenanceMetaData, authRole);
                
                return MaintenanceMetaDataResponse.builder()
                        .tabs(tabResponse)
                        .build();
            } else {
                throw new IllegalArgumentException("Authorization role is missing or invalid.");
            }
        }
        return new MaintenanceMetaDataResponse();
    } catch (Exception exception) {
        log.error("Failed to fetch Maintenance Info: ", exception);
        throw new RuntimeException(exception);
    }
}
---------
import java.util.Optional;

private TabResponse getTabResponse(Tab tab, String authRole) {
    // Use Optional to safely handle null attributes
    Optional<List<Attribute>> optionalAttributes = Optional.ofNullable(tab.getAttributes());

    // Check if attributes are present and not empty
    if (optionalAttributes.isPresent() && !optionalAttributes.get().isEmpty()) {
        return TabResponse.builder()
                .name(tab.getName())
                .attributes(optionalAttributes.get().stream()
                        .filter(attribute -> attribute.getIsEditableBy().contains(authRole))
                        .map(attribute -> AttributeResponse.builder()
                                .name(attribute.getName())
                                .maintenanceType(attribute.getMaintenanceType())
                                .cicImpacted(attribute.getCicImpacted() != null && attribute.getCicImpacted())
                                .build())
                        .collect(Collectors.toList()))
                .build();
    } else {
        // Handle case where attributes are null or empty
        return TabResponse.builder()
                .name(tab.getName())
                .attributes(Collections.emptyList()) // or handle differently based on your requirements
                .build();
    }
}
-------
import java.util.Optional;

private TabResponse getTabResponse(Tab tab, String authRole) {
    return Optional.ofNullable(tab)
            .map(Tab::getAttributes)
            .map(attributes -> attributes.stream()
                    .filter(attribute -> attribute.getIsEditableBy().contains(authRole))
                    .map(attribute -> AttributeResponse.builder()
                            .name(attribute.getName())
                            .maintenanceType(attribute.getMaintenanceType())
                            .cicImpacted(attribute.getCicImpacted() != null && attribute.getCicImpacted())
                            .build())
                    .collect(Collectors.toList()))
            .filter(attributes -> !attributes.isEmpty()) // Check if attributes list is not empty
            .map(filteredAttributes -> TabResponse.builder()
                    .name(tab.getName())
                    .attributes(filteredAttributes)
                    .build())
            .orElse(null); // Return null if tab is null or attributes are null/empty
}
------------
private TabResponse getTabResponse(Tab tab, String authRole) {
    List<AttributeResponse> attributeResponses = new ArrayList<>();

    // Check if tab.getAttributes() is not null and not empty
    if (tab.getAttributes() != null && !tab.getAttributes().isEmpty()) {
        attributeResponses = tab.getAttributes().stream()
                .filter(attribute -> attribute.getIsEditableBy().contains(authRole))
                .map(attribute -> AttributeResponse.builder()
                        .name(attribute.getName())
                        .maintenanceType(attribute.getMaintenanceType())
                        .cicImpacted(attribute.getCicImpacted() != null && attribute.getCicImpacted())
                        .build())
                .collect(Collectors.toList());
    }

    return TabResponse.builder()
            .name(tab.getName())
            .attributes(attributeResponses)
            .build();
}
----------
@Override
public MaintenanceMetaDataResponse getMaintenanceMeta() {
    try {
        if (featureManager.isActive(ItemFeatures.ITEM_MAINTENANCE)) {
            Object authRoleObject = RequestContextManager.getValue(GlobalConstants.AUTHROLE);
            if (authRoleObject == null) {
                throw new IllegalStateException("Authentication role is null.");
            }
            String authRole = String.valueOf(authRoleObject).toUpperCase();
            if (authRole.isEmpty()) {
                throw new IllegalStateException("Authentication role is empty.");
            }
            
            List<TabModel> mentenanceMetaData = maintainMetadataRepository.findByTabsAttributesIsEditableByContaining(authRole);
            List<TabResponse> tabResponse = processTabs(mentenanceMetaData, authRole);
            return MaintenanceMetaDataResponse.builder()
                    .tabs(tabResponse)
                    .build();
        }
        return new MaintenanceMetaDataResponse();
    } catch (Exception exception) {
        log.error("Failed to fetch Maintenance Info: ", exception);
        throw new RuntimeException(exception);
    }
}
----------
@Override
public MaintenanceMetaDataResponse getMaintenanceMeta() {
    try {
        if (featureManager.isActive(ItemFeatures.ITEM_MAINTENANCE)) {
            String authRole = Optional.ofNullable(RequestContextManager.getValue(GlobalConstants.AUTHROLE))
                    .map(String::valueOf)
                    .orElseThrow(() -> new IllegalStateException("Authentication role is null."));
            
            authRole = authRole.toUpperCase(); // Convert to uppercase
            
            List<TabModel> mentenanceMetaData = maintainMetadataRepository.findByTabsAttributesIsEditableByContaining(authRole);
            List<TabResponse> tabResponse = processTabs(mentenanceMetaData, authRole);
            
            return MaintenanceMetaDataResponse.builder()
                    .tabs(tabResponse)
                    .build();
        }
        return new MaintenanceMetaDataResponse();
    } catch (Exception exception) {
        log.error("Failed to fetch Maintenance Info: ", exception);
        throw new RuntimeException(exception);
    }
}
-----------
@Override
public MaintenanceMetaDataResponse getMaintenanceMeta() {
    try {
        if (featureManager.isActive(ItemFeatures.ITEM_MAINTENANCE)) {
            String authRole = Optional.ofNullable((String) RequestContextManager.getValue(GlobalConstants.AUTHROLE))
                    .orElseThrow(() -> new IllegalStateException("Authentication role is null or empty."));
            
            authRole = authRole.toUpperCase(); // Convert to uppercase
            
            List<TabModel> mentenanceMetaData = maintainMetadataRepository.findByTabsAttributesIsEditableByContaining(authRole);
            List<TabResponse> tabResponse = processTabs(mentenanceMetaData, authRole);
            
            return MaintenanceMetaDataResponse.builder()
                    .tabs(tabResponse)
                    .build();
        }
        return new MaintenanceMetaDataResponse();
    } catch (Exception exception) {
        log.error("Failed to fetch Maintenance Info: ", exception);
        throw new RuntimeException(exception);
    }
}
------------------package com.albertsons.meitem.service.maintanance.impl;

import com.albertsons.meitem.constants.GlobalConstants;
import com.albertsons.meitem.features.ItemFeatures;
import com.albertsons.meitem.model.mongo.maintenance.Attribute;
import com.albertsons.meitem.model.mongo.maintenance.Tab;
import com.albertsons.meitem.model.mongo.maintenance.TabModel;
import com.albertsons.meitem.repository.mongo.MaintainMetadataRepository;
import com.albertsons.meitem.response.maintenace.AttributeResponse;
import com.albertsons.meitem.response.maintenace.MaintenanceMetaDataResponse;
import com.albertsons.meitem.response.maintenace.TabResponse;
import com.albertsons.meitem.service.maintanance.MaintenanceMetaDataService;
import com.albertsons.meitem.utils.RequestContextManager;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;
import org.togglz.core.manager.FeatureManager;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

@Service
@Slf4j
@RequiredArgsConstructor
public class MaintenanceMetaDataServiceImpl implements MaintenanceMetaDataService {

    private final MaintainMetadataRepository maintainMetadataRepository;
    private final FeatureManager featureManager;

    /**
     * Retrieves maintenance metadata based on the user's role.
     * This method fetches filter data from the maintain_metadata collection.
     * If the feature flag ITEM_MAINTENANCE is active, it returns the metadata.
     * Otherwise, an empty response is returned.
     *
     * @return A MaintenanceMetaDataResponse containing information about tabs and attributes.
     * @throws RuntimeException if there's an error fetching the maintenance info.
     */

    @Override
    public MaintenanceMetaDataResponse getMaintenanceMeta() {
        try {
            if (featureManager.isActive(ItemFeatures.ITEM_MAINTENANCE)) {
                String authRole = Optional.ofNullable((String) RequestContextManager.getValue(GlobalConstants.AUTHROLE))
                        .orElseThrow(() -> new IllegalStateException("Authentication role is null or empty."));
                authRole = authRole.toUpperCase();
                List<TabModel> mentenanceMetaData = maintainMetadataRepository.findByTabsAttributesIsEditableByContaining(authRole);
                List<TabResponse> tabResponse = processTabs(mentenanceMetaData, authRole);
                return MaintenanceMetaDataResponse.builder()
                        .tabs(tabResponse)
                        .build();
            }
            return new MaintenanceMetaDataResponse();
        } catch (Exception exception) {
            log.error("Failed to fetch Maintenance Info: ", exception);
            throw new RuntimeException(exception);
        }
    }

    private List<TabResponse> processTabs(List<TabModel> mentenanceMetaData, String authRole) {
        List<TabResponse> tabResponse = mentenanceMetaData.stream()
                .flatMap(metaData -> metaData.getTabs().stream()
                        .map(tab -> getTabResponse(tab, authRole)))
                .collect(Collectors.toList());
        return tabResponse;
    }

    private TabResponse getTabResponse(Tab tab, String authRole) {
        List<AttributeResponse> attributeResponses = new ArrayList<>();
        if (tab.getAttributes() != null && !tab.getAttributes().isEmpty()) {
            attributeResponses = tab.getAttributes().stream()
                    .filter(attribute -> attribute.getIsEditableBy().contains(authRole))
                    .map(attribute -> AttributeResponse.builder()
                            .name(attribute.getName())
                            .maintenanceType(attribute.getMaintenanceType())
                            .cicImpacted(attribute.getCicImpacted() != null && attribute.getCicImpacted())
                            .build())
                    .collect(Collectors.toList());
        }
        return TabResponse.builder()
                .name(tab.getName())
                .attributes(attributeResponses)
                .build();
    }

    public TabModel filterAttributesByEditableBy(TabModel tabsCollection, String editableBy) {
        List<Tab> filteredTabs = tabsCollection.getTabs().stream().map(tab -> {
            List<Attribute> filteredAttributes = tab.getAttributes().stream().filter(attr -> attr.getIsEditableBy().contains(editableBy)).collect(Collectors.toList());
            tab.setAttributes(filteredAttributes);
            return tab;
        }).filter(tab -> !tab.getAttributes().isEmpty()).collect(Collectors.toList());
        tabsCollection.setTabs(filteredTabs);
        return tabsCollection;
    }

}


-----------------
private TabResponse getTabResponse(Tab tab, String authRole) {
    List<AttributeResponse> attributeResponses = Optional.ofNullable(tab.getAttributes())
            .orElse(Collections.emptyList())
            .stream()
            .filter(attribute -> {
                List<String> isEditableBy = attribute.getIsEditableBy();
                return isEditableBy != null && !isEditableBy.isEmpty() && isEditableBy.contains(authRole);
            })
            .map(attribute -> AttributeResponse.builder()
                    .name(attribute.getName())
                    .maintenanceType(attribute.getMaintenanceType())
                    .cicImpacted(Boolean.TRUE.equals(attribute.getCicImpacted()))
                    .build())
            .collect(Collectors.toList());

    return TabResponse.builder()
            .name(tab.getName())
            .attributes(attributeResponses)
            .build();
}
-----------
private TabResponse getTabResponse(Tab tab, String authRole) {
    List<AttributeResponse> attributeResponses = new ArrayList<>();
    
    if (tab.getAttributes() != null && !tab.getAttributes().isEmpty()) {
        attributeResponses = tab.getAttributes().stream()
                .filter(attribute -> {
                    List<String> isEditableBy = attribute.getIsEditableBy();
                    return isEditableBy != null && !isEditableBy.isEmpty() && isEditableBy.contains(authRole);
                })
                .map(attribute -> AttributeResponse.builder()
                        .name(attribute.getName())
                        .maintenanceType(attribute.getMaintenanceType())
                        .cicImpacted(attribute.getCicImpacted() != null && attribute.getCicImpacted())
                        .build())
                .collect(Collectors.toList());
    }
    
    return TabResponse.builder()
            .name(tab.getName())
            .attributes(attributeResponses)
            .build();
}
-----------
public TabModel filterAttributesByEditableBy(TabModel tabsCollection, String editableBy) {
    List<Tab> filteredTabs = tabsCollection.getTabs().stream()
            .map(tab -> {
                List<Attribute> filteredAttributes = tab.getAttributes().stream()
                        .filter(attr -> attr.getIsEditableBy().contains(editableBy))
                        .collect(Collectors.toList());
                tab.setAttributes(filteredAttributes);
                return tab;
            })
            .filter(tab -> !tab.getAttributes().isEmpty())
            .collect(Collectors.toList());
    
    tabsCollection.setTabs(filteredTabs);
    return tabsCollection;
}

